Ext.data.JsonP.Promise({"tagname":"class","name":"Promise","autodetected":{},"files":[{"filename":"When.js","href":"When.html#Promise"}],"extends":"External","author":[{"tagname":"author","name":"Brian Cavalier","email":null}],"members":[{"name":"catch","tagname":"method","owner":"Promise","id":"method-catch","meta":{}},{"name":"done","tagname":"method","owner":"Promise","id":"method-done","meta":{}},{"name":"finally","tagname":"method","owner":"Promise","id":"method-finally","meta":{}},{"name":"inspect","tagname":"method","owner":"Promise","id":"method-inspect","meta":{}},{"name":"spread","tagname":"method","owner":"Promise","id":"method-spread","meta":{}},{"name":"tap","tagname":"method","owner":"Promise","id":"method-tap","meta":{}},{"name":"then","tagname":"method","owner":"Promise","id":"method-then","meta":{}},{"name":"yield","tagname":"method","owner":"Promise","id":"method-yield","meta":{}}],"alternateClassNames":[],"aliases":{},"id":"class-Promise","short_doc":"The promise represents the eventual outcome, which is either fulfillment (success) and an associated value,\nor reject...","classIcon":"icon-class","superclasses":["External"],"subclasses":[],"mixedInto":[],"mixins":[],"parentMixins":[],"requires":[],"uses":[],"html":"<div><pre class=\"hierarchy\"><h4>Hierarchy</h4><div class='subclass first-child'>External<div class='subclass '><strong>Promise</strong></div></div><h4>Files</h4><div class='dependency'><a href='source/When.html#Promise' target='_blank'>When.js</a></div></pre><div class='doc-contents'><p>The promise represents the <em>eventual outcome</em>, which is either fulfillment (success) and an associated value,\nor rejection (failure) and an associated reason. The promise provides mechanisms for arranging to call a\nfunction on its value or reason, and produces a new promise for the result.</p>\n\n<pre><code>// Create a pending promise whose fate is detemined by\n// the provided resolver function\nvar promise = when.promise(resolver);\n\n// Or a resolved promise\nvar promise = when.resolve(promiseOrValue);\n\n// Or a rejected promise\nvar promise = when.reject(reason);\n</code></pre>\n\n<blockquote><p><strong>Note</strong> : This documentation was copied from the <a href=\"https://github.com/cujojs/when/blob/master/docs/api.md#promise\">when.js API documentation</a>.</p></blockquote>\n</div><div class='members'><div class='members-section'><div class='definedBy'>Defined By</div><h3 class='members-title icon-method'>Methods</h3><div class='subsection'><div id='method-catch' class='member first-child not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Promise'>Promise</span><br/><a href='source/When.html#Promise-method-catch' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Promise-method-catch' class='name expandable'>catch</a>( <span class='pre'>onRejected</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Arranges to call onRejected on the promise's rejection reason if it is rejected. ...</div><div class='long'><p>Arranges to call <code>onRejected</code> on the promise's rejection reason if it is rejected.</p>\n\n<pre><code>promise.catch(onRejected);\n// or\npromise.otherwise(onRejected);\n</code></pre>\n\n<p> It's a shortcut for:</p>\n\n<pre><code>promise.then(undefined, onRejected);\n</code></pre>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>onRejected</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-done' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Promise'>Promise</span><br/><a href='source/When.html#Promise-method-done' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Promise-method-done' class='name expandable'>done</a>( <span class='pre'>handleValue, [handlerError]</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Consumes a promise as the final handler in a thenable chain. ...</div><div class='long'><p>Consumes a promise as the final handler in a thenable chain.</p>\n\n<pre><code>promise.done(handleValue, handleError);\n</code></pre>\n\n<p>One golden rule of promise error handling is:</p>\n\n<p>Either <code>return</code> the promise, thereby <em>passing the error-handling buck</em> to the caller, or call <a href=\"#!/api/Promise-method-done\" rel=\"Promise-method-done\" class=\"docClass\">done</a> and <em>assuming\nresponsibility for errors</em>.</p>\n\n<p>While <a href=\"#!/api/Promise-method-then\" rel=\"Promise-method-then\" class=\"docClass\">then</a> is the primary API for transforming a promise's value and producing a new promise for the transformed\nvalue, <a href=\"#!/api/Promise-method-done\" rel=\"Promise-method-done\" class=\"docClass\">done</a> is used to terminate a promise chain, and extract the final value or error. It signals that you\nare taking responsibility for the final outcome. If the chain was ultimately successful, <code>handleValue</code> will be\ncalled with the final value. If the chain was not successful and an error propagated to the end, <code>handleError</code> will be\ncalled with that error.</p>\n\n<p>Any error, either a returned rejection or a thrown exception, that propagates out of <code>handleValue</code> or <code>handleError</code>\nwill be rethrown to the host environment, thereby generating a loud stack trace (and in some cases, such as Node,\nhalting the VM). This provides immediate feedback for development time errors and mistakes, and greatly reduces\nthe chance of an unhandled promise rejection going silent.</p>\n\n<p>Note that there are still cases that <a href=\"#!/api/Promise-method-done\" rel=\"Promise-method-done\" class=\"docClass\">done</a> simply cannot catch, such as the case of <em>forgetting to call\n<a href=\"#!/api/Promise-method-done\" rel=\"Promise-method-done\" class=\"docClass\">done</a>!</em> Thus, <a href=\"#!/api/Promise-method-done\" rel=\"Promise-method-done\" class=\"docClass\">done</a> and the unhandled rejection monitor are complimentary in many ways. In fact,\nwhen the monitor is enabled, any error that escapes <code>handleValue</code> or <code>handleError</code> will also trigger the monitor.</p>\n\n<p>Since <a href=\"#!/api/Promise-method-done\" rel=\"Promise-method-done\" class=\"docClass\">done</a>'s purpose is consumption rather than transformation, <a href=\"#!/api/Promise-method-done\" rel=\"Promise-method-done\" class=\"docClass\">done</a> always returns <code>undefined</code>.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>handleValue</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a><div class='sub-desc'>\n</div></li><li><span class='pre'>handlerError</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a> (optional)<div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-finally' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Promise'>Promise</span><br/><a href='source/When.html#Promise-method-finally' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Promise-method-finally' class='name expandable'>finally</a>( <span class='pre'>onFulfilledOrRejected</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Finally allows you to execute \"cleanup\" type tasks in a promise chain. ...</div><div class='long'><p>Finally allows you to execute \"cleanup\" type tasks in a promise chain.</p>\n\n<pre><code>promise.finally(onFulfilledOrRejected);\n// or\npromise.ensure(onFulfilledOrRejected);\n</code></pre>\n\n<p>It arranges for <code>onFulfilledOrRejected</code> to be called, <em>with no arguments</em>, when promise is either fulfilled or rejected.\n<code>onFulfilledOrRejected</code> cannot modify promise's fulfillment value, but may signal a new or additional error by\nthrowing an exception or returning a rejected promise.</p>\n\n<p><a href=\"#!/api/Promise-method-finally\" rel=\"Promise-method-finally\" class=\"docClass\">finally</a> should be used instead of <code>promise.always.</code> It is safer in that it <em>cannot</em> transform a failure\ninto a success by accident (which <code>always</code> could do simply by returning successfully!).</p>\n\n<p>When combined with <a href=\"#!/api/Promise-method-catch\" rel=\"Promise-method-catch\" class=\"docClass\">catch</a>, <a href=\"#!/api/Promise-method-finally\" rel=\"Promise-method-finally\" class=\"docClass\">finally</a> allows you to write code that is similar to the familiar\nsynchronous <code>catch/finally</code> pair. Consider the following synchronous code:</p>\n\n<pre><code>try {\n    return doSomething(x);\n} catch(e) {\n    return handleError(e);\n} finally {\n    cleanup();\n}\n</code></pre>\n\n<p>Using <a href=\"#!/api/Promise-method-finally\" rel=\"Promise-method-finally\" class=\"docClass\">finally</a>, similar asynchronous code (with <code>doSomething()</code> that returns a promise) can be written:</p>\n\n<pre><code>return doSomething()\n    .catch(handleError)\n    .finally(cleanup);\n</code></pre>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>onFulfilledOrRejected</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-inspect' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Promise'>Promise</span><br/><a href='source/When.html#Promise-method-inspect' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Promise-method-inspect' class='name expandable'>inspect</a>( <span class='pre'></span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns a snapshot descriptor of the current state of promise. ...</div><div class='long'><p>Returns a snapshot descriptor of the current state of <code>promise</code>.</p>\n\n<pre><code>var status = promise.inspect();\n</code></pre>\n\n<p>This descriptor is <em>not live</em> and will not update when <code>promise</code>'s state changes.\nThe descriptor is an object with the following properties. When promise is:</p>\n\n<ul>\n<li>pending: <code>{ state: 'pending' }</code></li>\n<li>fulfilled: <code>{ state: 'fulfilled', value: &lt;promise's fulfillment value&gt; }</code></li>\n<li>rejected: <code>{ state: 'rejected', reason: &lt;promise's rejection reason&gt; }</code></li>\n</ul>\n\n\n<p>While there are use cases where synchronously inspecting a promise's state can be helpful, the use of <a href=\"#!/api/Promise-method-inspect\" rel=\"Promise-method-inspect\" class=\"docClass\">inspect</a>\nis discouraged. It is almost always preferable to simply use <code>when()</code> or <a href=\"#!/api/Promise-method-then\" rel=\"Promise-method-then\" class=\"docClass\">then</a> to be notified when the\npromise fulfills or rejects.</p>\n</div></div></div><div id='method-spread' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Promise'>Promise</span><br/><a href='source/When.html#Promise-method-spread' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Promise-method-spread' class='name expandable'>spread</a>( <span class='pre'>variadicOnFulfilled</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Arranges to call variadicOnFulfilled with promise's values, which is assumed to be an array, as its argument list,\ne.g. ...</div><div class='long'><p>Arranges to call <code>variadicOnFulfilled</code> with promise's values, which is assumed to be an array, as its argument list,\ne.g. <code>variadicOnFulfilled.spread(undefined, array)</code>.</p>\n\n<pre><code>promise.spread(variadicOnFulfilled);\n</code></pre>\n\n<p>It's a shortcut for either of the following:</p>\n\n<pre><code>// Wrapping variadicOnFulfilled\npromise.then(function(array) {\n    return variadicOnFulfilled.apply(undefined, array);\n});\n\n// Or using when/apply\npromise.then(apply(variadicOnFulfilled));\n</code></pre>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>variadicOnFulfilled</span> : (<a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a>|*)[]<div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-tap' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Promise'>Promise</span><br/><a href='source/When.html#Promise-method-tap' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Promise-method-tap' class='name expandable'>tap</a>( <span class='pre'>onFulfilledSideEffect</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Executes a function as a side effect when promise fulfills. ...</div><div class='long'><p>Executes a function as a side effect when <code>promise</code> fulfills.</p>\n\n<pre><code>promise.tap(onFulfilledSideEffect);\n</code></pre>\n\n<p>Returns a new promise:</p>\n\n<ul>\n<li>If <code>promise</code> fulfills, <code>onFulfilledSideEffect</code> is executed:\n\n<ul>\n<li>If <code>onFulfilledSideEffect</code> returns successfully, the promise returned by <a href=\"#!/api/Promise-method-tap\" rel=\"Promise-method-tap\" class=\"docClass\">tap</a> fulfills with <code>promise</code>'s\noriginal fulfillment value. That is, <code>onfulfilledSideEffect</code>'s result is discarded.</li>\n<li>If <code>onFulfilledSideEffect</code> throws or returns a rejected promise, the promise returned by <a href=\"#!/api/Promise-method-tap\" rel=\"Promise-method-tap\" class=\"docClass\">tap</a> rejects with\nthe same reason.</li>\n</ul>\n</li>\n<li>If <code>promise</code> rejects, <code>onFulfilledSideEffect</code> is <em>not</em> executed, and the promise returned by <a href=\"#!/api/Promise-method-tap\" rel=\"Promise-method-tap\" class=\"docClass\">tap</a> rejects\nwith <code>promise</code>'s rejection reason.</li>\n</ul>\n\n\n<p>These are equivalent:</p>\n\n<pre><code>// Using only .then()\npromise.then(function(x) {\n    doSideEffectsHere(x);\n    return x;\n});\n\n// Using .tap()\npromise.tap(doSideEffectsHere);\n</code></pre>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>onFulfilledSideEffect</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-then' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Promise'>Promise</span><br/><a href='source/When.html#Promise-method-then' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Promise-method-then' class='name expandable'>then</a>( <span class='pre'>onFulfilled, [onRejected], [onProgress]</span> ) : <a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a><span class=\"signature\"></span></div><div class='description'><div class='short'>The primary API for transforming a promise's value and producing a new promise for the transformed result,\nor for han...</div><div class='long'><p>The primary API for transforming a promise's value and producing a new promise for the transformed result,\nor for handling and recovering from intermediate errors in a promise chain.</p>\n\n<pre><code>// Main promise API\nvar newPromise = promise.then(onFulfilled, onRejected, onProgress);\n</code></pre>\n\n<p>It arranges for:</p>\n\n<ul>\n<li><code>onFulfilled</code> to be called with the value after promise is fulfilled, or</li>\n<li><code>onRejected</code> to be called with the rejection reason after promise is rejected.</li>\n<li><code>onProgress</code> to be called with any progress updates issued by promise.</li>\n</ul>\n\n\n<p>Returns a trusted promise that will fulfill with the return value of either <code>onFulfilled</code> or <code>onRejected</code>,\nwhichever is called, or will reject with the thrown exception if either throws.</p>\n\n<p>A promise makes the following guarantees about handlers registered in the same call to <code>.then()</code>:</p>\n\n<ul>\n<li>Only one of <code>onFulfilled</code> or <code>onRejected</code> will be called, never both.</li>\n<li><code>onFulfilled</code> and <code>onRejected</code> will never be called more than once.</li>\n<li><code>onProgress</code> may be called multiple times.</li>\n</ul>\n\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>onFulfilled</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a><div class='sub-desc'>\n</div></li><li><span class='pre'>onRejected</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a> (optional)<div class='sub-desc'>\n</div></li><li><span class='pre'>onProgress</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a> (optional)<div class='sub-desc'>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a></span><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-yield' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='Promise'>Promise</span><br/><a href='source/When.html#Promise-method-yield' target='_blank' class='view-source'>view source</a></div><a href='#!/api/Promise-method-yield' class='name expandable'>yield</a>( <span class='pre'>promiseOrValue</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Returns a yielded promise\n\noriginalPromise.yield(promiseOrValue);\n\n\n\nIf originalPromise is rejected, the returned pro...</div><div class='long'><p>Returns a yielded promise</p>\n\n<pre><code>originalPromise.yield(promiseOrValue);\n</code></pre>\n\n<ul>\n<li>If <code>originalPromise</code> is rejected, the returned promise will be rejected with the same reason</li>\n<li>If <code>originalPromise</code> is fulfilled, then it \"yields\" the resolution of the returned promise to <code>promiseOrValue</code>, namely:\n\n<ul>\n<li>If <code>promiseOrValue</code> is a value, the returned promise will be fulfilled with <code>promiseOrValue</code></li>\n<li>If <code>promiseOrValue</code> is a <a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">promise</a>, the returned promise will be:\n\n<ul>\n<li>fulfilled with the fulfillment value of <code>promiseOrValue</code>, or</li>\n<li>rejected with the rejection reason of <code>promiseOrValue</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n\n<p>In other words, it's much like:</p>\n\n<pre><code>originalPromise.then(function() {\n    return promiseOrValue;\n});\n</code></pre>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>promiseOrValue</span> : <a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a>|*<div class='sub-desc'>\n</div></li></ul></div></div></div></div></div></div></div>","meta":{}});