Ext.data.JsonP.When({"tagname":"class","name":"When","autodetected":{},"files":[{"filename":"When.js","href":"When.html#When"}],"static":true,"members":[{"name":"all","tagname":"method","owner":"When","id":"static-method-all","meta":{"static":true}},{"name":"any","tagname":"method","owner":"When","id":"static-method-any","meta":{"static":true}},{"name":"defer","tagname":"method","owner":"When","id":"static-method-defer","meta":{"static":true}},{"name":"isPromiseLike","tagname":"method","owner":"When","id":"static-method-isPromiseLike","meta":{"static":true}},{"name":"join","tagname":"method","owner":"When","id":"static-method-join","meta":{"static":true}},{"name":"map","tagname":"method","owner":"When","id":"static-method-map","meta":{"static":true}},{"name":"promise","tagname":"method","owner":"When","id":"static-method-promise","meta":{"static":true}},{"name":"reduce","tagname":"method","owner":"When","id":"static-method-reduce","meta":{"static":true}},{"name":"reject","tagname":"method","owner":"When","id":"static-method-reject","meta":{"static":true}},{"name":"resolve","tagname":"method","owner":"When","id":"static-method-resolve","meta":{"static":true}},{"name":"settle","tagname":"method","owner":"When","id":"static-method-settle","meta":{"static":true}},{"name":"some","tagname":"method","owner":"When","id":"static-method-some","meta":{"static":true}}],"alternateClassNames":[],"aliases":{},"id":"static-class-When","short_doc":"A lightweight CommonJS Promises/A and when() implementation. ...","classIcon":"icon-class","superclasses":[],"subclasses":[],"mixedInto":[],"mixins":[],"parentMixins":[],"requires":[],"uses":[],"html":"<div><pre class=\"hierarchy\"><h4>Files</h4><div class='dependency'><a href='source/When.html#When' target='_blank'>When.js</a></div></pre><div class='doc-contents'><p>A lightweight CommonJS Promises/A and when() implementation.</p>\n\n<blockquote><p><strong>Note</strong> : This documentation was copied from the <a href=\"https://github.com/cujojs/when/blob/master/docs/api.md#when\">when.js API documentation</a>.\nwhen is part of the cujo.js family of libraries (http://cujojs.com/)</p></blockquote>\n</div><div class='members'><div class='members-section'><h3 class='members-title icon-method'>Methods</h3><div class='subsection'><div class='definedBy'>Defined By</div><h4 class='members-subtitle'>Static methods</h3><div id='static-method-all' class='member first-child not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='When'>When</span><br/><a href='source/When.html#When-static-method-all' target='_blank' class='view-source'>view source</a></div><a href='#!/api/When-static-method-all' class='name expandable'>all</a>( <span class='pre'>promisesOrValues</span> ) : <a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a><span class=\"signature\"><span class='static' >static</span></span></div><div class='description'><div class='short'>Return a promise that will resolve only once all the items in array have resolved. ...</div><div class='long'><p>Return a promise that will resolve only once all the items in array have resolved. The resolution value of the returned promise will be an array containing the resolution values of each of the items in array.\nIf any of the promises is rejected, the returned promise will be rejected with the rejection reason of the first promise that was rejected.</p>\n\n<pre><code>var promise = when.all(array)\n</code></pre>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>promisesOrValues</span> : Array|<a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a><div class='sub-desc'><p>array of anything, may contain a mix of promises and values</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a></span><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='static-method-any' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='When'>When</span><br/><a href='source/When.html#When-static-method-any' target='_blank' class='view-source'>view source</a></div><a href='#!/api/When-static-method-any' class='name expandable'>any</a>( <span class='pre'></span> ) : <a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a><span class=\"signature\"><span class='static' >static</span></span></div><div class='description'><div class='short'>Initiates a competitive race that allows one winner, returning a promise that will resolve when\nany one of the items ...</div><div class='long'><p>Initiates a competitive race that allows one winner, returning a promise that will resolve when\nany one of the items in array resolves. The returned promise will only reject if all items in array\nare rejected. The resolution value of the returned promise will be the fulfillment value of the\nwinning promise. The rejection value will be an array of all rejection reasons.</p>\n\n<pre><code>var promise = when.any(array)\n</code></pre>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a></span><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='static-method-defer' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='When'>When</span><br/><a href='source/When.html#When-static-method-defer' target='_blank' class='view-source'>view source</a></div><a href='#!/api/When-static-method-defer' class='name expandable'>defer</a>( <span class='pre'></span> ) : <a href=\"#!/api/Deferred\" rel=\"Deferred\" class=\"docClass\">Deferred</a><span class=\"signature\"><span class='static' >static</span></span></div><div class='description'><div class='short'>Create a {promise, resolver} pair, aka Deferred. ...</div><div class='long'><p>Create a {promise, resolver} pair, aka Deferred. In some scenarios it can be convenient to have\naccess to both the promise and it's associated resolving functions, for example, to give each out to a separate party. In such cases it can be convenient to use when.defer().</p>\n\n<pre><code>var deferred = when.defer();\nvar promise = deferred.promise;\n...\ndefered.resolver.resolve();\ndefered.resolver.reject();\n</code></pre>\n<h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Deferred\" rel=\"Deferred\" class=\"docClass\">Deferred</a></span><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='static-method-isPromiseLike' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='When'>When</span><br/><a href='source/When.html#When-static-method-isPromiseLike' target='_blank' class='view-source'>view source</a></div><a href='#!/api/When-static-method-isPromiseLike' class='name expandable'>isPromiseLike</a>( <span class='pre'>x</span> ) : Boolean<span class=\"signature\"><span class='static' >static</span></span></div><div class='description'><div class='short'>Return true if anything is an object or function with a then method. ...</div><div class='long'><p>Return true if anything is an object or function with a then method. It does not distinguish\ntrusted when.js promises from other \"thenables\" (e.g. from some other promise implementation).</p>\n\n<pre><code>var is = when.isPromiseLike(anything);\n</code></pre>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>x</span> : *<div class='sub-desc'><p>anything</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>Boolean</span><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='static-method-join' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='When'>When</span><br/><a href='source/When.html#When-static-method-join' target='_blank' class='view-source'>view source</a></div><a href='#!/api/When-static-method-join' class='name expandable'>join</a>( <span class='pre'>promises</span> ) : <a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a><span class=\"signature\"><span class='static' >static</span></span></div><div class='description'><div class='short'>Return a promise that will resolve only once all the inputs have resolved. ...</div><div class='long'><p>Return a promise that will resolve only once all the inputs have resolved. The resolution value\nof the returned promise will be an array containing the resolution values of each of the inputs.\nIf any of the input promises is rejected, the returned promise will be rejected with the reason from the first one that is rejected.</p>\n\n<pre><code>var joinedPromise = when.join(promiseOrValue1, promiseOrValue2, ...);\n\n// largerPromise will resolve to the greater of two eventual values\nvar largerPromise = when.join(promise1, promise2).then(function (values) {\n    return values[0] &gt; values[1] ? values[0] : values[1];\n});\n</code></pre>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>promises</span> : ...<a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a><div class='sub-desc'><p>One or more promises.</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a></span><div class='sub-desc'><p>a promise that will fulfill when <em>all</em> the input promises have fulfilled, or\nwill reject when <em>any one</em> of the input promises rejects.</p>\n</div></li></ul></div></div></div><div id='static-method-map' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='When'>When</span><br/><a href='source/When.html#When-static-method-map' target='_blank' class='view-source'>view source</a></div><a href='#!/api/When-static-method-map' class='name expandable'>map</a>( <span class='pre'>array, mapFunc</span> ) : <a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a><span class=\"signature\"><span class='static' >static</span></span></div><div class='description'><div class='short'>Traditional array map function, similar to Array.prototype.map(), but allows input to contain promises and/or values,...</div><div class='long'><p>Traditional array map function, similar to Array.prototype.map(), but allows input to contain promises and/or values, and mapFunc may return either a value or a promise.\nIf any of the promises is rejected, the returned promise will be rejected with the rejection reason of the first promise that was rejected.</p>\n\n<pre><code>var promise = when.map(array, mapFunc)\n</code></pre>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>array</span> : Array|<a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a><div class='sub-desc'><p>array of anything, may contain promises and values</p>\n</div></li><li><span class='pre'>mapFunc</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a><div class='sub-desc'><p>map function which may return a promise or value</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>item</span> : *<div class='sub-desc'><p>item A fully resolved value</p>\n</div></li></ul></div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a></span><div class='sub-desc'><p>promise that will fulfill with an array of mapped values or reject if any input promise rejects.</p>\n</div></li></ul></div></div></div><div id='static-method-promise' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='When'>When</span><br/><a href='source/When.html#When-static-method-promise' target='_blank' class='view-source'>view source</a></div><a href='#!/api/When-static-method-promise' class='name expandable'>promise</a>( <span class='pre'>resolver</span> ) : <a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a><span class=\"signature\"><span class='static' >static</span></span></div><div class='description'><div class='short'>Create a Promise, whose fate is determined by the supplied resolver function. ...</div><div class='long'><p>Create a Promise, whose fate is determined by the supplied resolver function. The resolver function will be called synchronously.</p>\n\n<pre><code>var promise = when.promise(function(resolve, reject, notify) {\n    // Do some work, possibly asynchronously, and then\n    // resolve or reject.  You can notify of progress events\n    // along the way if you want/need.\n\n    resolve(awesomeResult);\n    // or resolve(anotherPromise);\n    // or reject(nastyError);\n});\n</code></pre>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>resolver</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a><div class='sub-desc'><p>The resolver function to determinate this promise.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>resolve</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a><div class='sub-desc'><p>(valueOrPromise) Primary function that seals the fate of the returned promise.\nAccepts either a non-promise value, or another promise. When called with a non-promise value, fulfills\npromise with that value, When called with another promise, promise's fate will be equivalent to\nthat that of otherPromise.</p>\n</div></li><li><span class='pre'>reject</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a><div class='sub-desc'><p>(reason) function that rejects promise</p>\n</div></li><li><span class='pre'>notify</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a><div class='sub-desc'><p>(update) function that issues progress events for promise with update.</p>\n</div></li></ul></div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a></span><div class='sub-desc'><p>promise whose fate is determine by resolver</p>\n</div></li></ul></div></div></div><div id='static-method-reduce' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='When'>When</span><br/><a href='source/When.html#When-static-method-reduce' target='_blank' class='view-source'>view source</a></div><a href='#!/api/When-static-method-reduce' class='name expandable'>reduce</a>( <span class='pre'>promise, reducer</span> ) : <a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a><span class=\"signature\"><span class='static' >static</span></span></div><div class='description'><div class='short'>Traditional array reduce function, similar to Array.prototype.reduce(), but input may contain promises\nand/or values,...</div><div class='long'><p>Traditional array reduce function, similar to Array.prototype.reduce(), but input may contain promises\nand/or values, and reduceFunc may return either a value or a promise, and initialValue may be a promise for the starting value.</p>\n\n<pre><code>var promise = when.reduce(array, reduceFunc [, initialValue])\n</code></pre>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>promise</span> : Array|<a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a><div class='sub-desc'><p>array or promise for an array of anything, may contain a mix of promises and values.</p>\n</div></li><li><span class='pre'>reducer</span> : <a href=\"#!/api/Function\" rel=\"Function\" class=\"docClass\">Function</a><div class='sub-desc'><p>The reduce function.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>currentResult</span> : *<div class='sub-desc'><p>The the current accumulated reduce value.</p>\n</div></li><li><span class='pre'>value</span> : *<div class='sub-desc'><p>the fully resolved value at index in array.</p>\n</div></li><li><span class='pre'>index</span> : Number<div class='sub-desc'><p>the basis of value, practically speaking, this is the array index of the array corresponding to value.</p>\n</div></li><li><span class='pre'>total</span> : Number<div class='sub-desc'><p>the total number of items in array.</p>\n</div></li></ul></div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a></span><div class='sub-desc'><p>that will resolve to the final reduced value</p>\n</div></li></ul></div></div></div><div id='static-method-reject' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='When'>When</span><br/><a href='source/When.html#When-static-method-reject' target='_blank' class='view-source'>view source</a></div><a href='#!/api/When-static-method-reject' class='name expandable'>reject</a>( <span class='pre'>promiseOrValue</span> ) : <a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a><span class=\"signature\"><span class='static' >static</span></span></div><div class='description'><div class='short'>Create a rejected promise with the supplied error as the rejection reason. ...</div><div class='long'><p>Create a rejected promise with the supplied error as the rejection reason.</p>\n\n<pre><code>var rejected = when.reject(error);\n</code></pre>\n\n<p><strong>DEPRECATION WARNING</strong>: In when.js 2.x, error is allowed to be a promise for an error.\nIn when.js 3.0, error will always be used verbatim as the rejection reason, even if it is a promise.</p>\n\n<p>If error is a value, it will be the rejection reason of the returned promise.\nIf error is a promise, its rejection reason will be the rejection reason of the returned promise.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>promiseOrValue</span> : *<div class='sub-desc'><p>the rejected value of the returned promise.</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a></span><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='static-method-resolve' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='When'>When</span><br/><a href='source/When.html#When-static-method-resolve' target='_blank' class='view-source'>view source</a></div><a href='#!/api/When-static-method-resolve' class='name expandable'>resolve</a>( <span class='pre'>value</span> ) : <a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a><span class=\"signature\"><span class='static' >static</span></span></div><div class='description'><div class='short'>Create a resolved promise for the supplied promiseOrValue. ...</div><div class='long'><p>Create a resolved promise for the supplied promiseOrValue. If promiseOrValue is a value, it will\nbe the resolution value of the returned promise. Returns promiseOrValue if it's a trusted promise.\nIf promiseOrValue is a foreign promise, returns a promise in the same state (resolved or rejected)\nand with the same value as promiseOrValue.</p>\n\n<pre><code>var resolved = when.resolve(promiseOrValue);\n</code></pre>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>value</span> : *<div class='sub-desc'>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a></span><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='static-method-settle' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='When'>When</span><br/><a href='source/When.html#When-static-method-settle' target='_blank' class='view-source'>view source</a></div><a href='#!/api/When-static-method-settle' class='name expandable'>settle</a>( <span class='pre'>array</span> ) : <a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a><span class=\"signature\"><span class='static' >static</span></span></div><div class='description'><div class='short'>Returns a promise for an array containing the same number of elements as the input array. ...</div><div class='long'><p>Returns a promise for an array containing the same number of elements as the input array.\nEach element is a descriptor object describing of the outcome of the corresponding element in the input.\nThe returned promise will only reject if array itself is a rejected promise. Otherwise, it will always\nfulfill with an array of descriptors. This is in contrast to when.all, which will reject if any element of array rejects.</p>\n\n<pre><code>// Process all successful results, and also log all errors\n\n// Input array\nvar array = [when.reject(1), 2, when.resolve(3), when.reject(4)];\n\n// Settle all inputs\nvar settled = when.settle(array);\n\n// Logs 1 &amp; 4 and processes 2 &amp; 3\nsettled.then(function(descriptors) {\n    descriptors.forEach(function(d) {\n        if(d.state === 'rejected') {\n            logError(d.reason);\n        } else {\n            processSuccessfulResult(d.value);\n        }\n    });\n});\n</code></pre>\n\n<p>Depending how the promise state is, the descriptor will be correspondingly:</p>\n\n<ul>\n<li>fulfilled: <code>{ state: 'fulfilled', value: &lt;fulfillmentValue&gt; }</code></li>\n<li>rejected: <code>{ state: 'rejected', reason: &lt;rejectionReason&gt; }</code></li>\n</ul>\n\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>array</span> : Array|<a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a><div class='sub-desc'><p>array or promise for array of promises to settle</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a></span><div class='sub-desc'><p>promise that always fulfills with an array of descriptors for each input promise.</p>\n</div></li></ul></div></div></div><div id='static-method-some' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='When'>When</span><br/><a href='source/When.html#When-static-method-some' target='_blank' class='view-source'>view source</a></div><a href='#!/api/When-static-method-some' class='name expandable'>some</a>( <span class='pre'>promisesOrValues, howMany</span> ) : <a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a><span class=\"signature\"><span class='static' >static</span></span></div><div class='description'><div class='short'>Initiates a competitive race that allows howMany winners, returning a promise that will resolve\nwhen howMany of the i...</div><div class='long'><p>Initiates a competitive race that allows howMany winners, returning a promise that will resolve\nwhen howMany of the items in array resolve. The returned promise will reject if it becomes impossible\nfor howMany items to resolve--that is, when (array.length - howMany) + 1 items reject. The resolution\nvalue of the returned promise will be an array of howMany winning promise fulfillment values.\nThe rejection value will be an array of (array.length - howMany) + 1 rejection reasons.</p>\n\n<pre><code>var promise = when.some(array, howMany)\n\n// try all of the p2p servers and fail if at least one doesn't respond\nvar remotes = [connect('p2p.cdn.com'), connect('p2p2.cdn.com'), connect('p2p3.cdn.com')];\nwhen.some(remotes, 1).then(initP2PServer, failGracefully);\n</code></pre>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>promisesOrValues</span> : Array<div class='sub-desc'><p>array of anything, may contain a mix of promises and values</p>\n</div></li><li><span class='pre'>howMany</span> : Object<div class='sub-desc'><p>{number} number of promisesOrValues to resolve</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'><a href=\"#!/api/Promise\" rel=\"Promise\" class=\"docClass\">Promise</a></span><div class='sub-desc'><p>promise that will resolve to an array of <code>howMany</code> values that resolved first,\nor will reject with an array of <code>(promisesOrValues.length - howMany) + 1</code> rejection reasons.</p>\n</div></li></ul></div></div></div></div></div></div></div>","meta":{"static":true}});