<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*
 * TroopJS requirejs/template
 * @license MIT http://troopjs.mit-license.org/ Â© Mikael Karon mailto:mikael@karon.se
 *
 * Parts of code from require-cs 0.4.0+ Copyright (c) 2010-2011, The Dojo Foundation
 */
define(function TemplateModule() {
	&quot;use strict&quot;;

	/*jshint rhino:true, node:true, wsh:true*/
	var FACTORIES = {
		&quot;node&quot; : function () {
			// Using special require.nodeRequire, something added by r.js.
			var fs = require.nodeRequire(&quot;fs&quot;);

			return function fetchText(path, callback) {
				var file = fs.readFileSync(path, &quot;utf8&quot;);
				//Remove BOM (Byte Mark Order) from utf8 files if it is there.
				if (file.indexOf(&quot;\uFEFF&quot;) === 0) {
					file = file.substring(1);
				}
				callback(file);
			};
		},

		&quot;browser&quot; : function () {
			/*jshint nonew:false, loopfunc:true*/
			// Would love to dump the ActiveX crap in here. Need IE 6 to die first.
			var progIds = [ &quot;Msxml2.XMLHTTP&quot;, &quot;Microsoft.XMLHTTP&quot;, &quot;Msxml2.XMLHTTP.4.0&quot;];
			var progId;
			var XHR;
			var i;

			if (typeof XMLHttpRequest !== &quot;undefined&quot;) {
				XHR = XMLHttpRequest;
			}
			else {
				for (i = 0; i &lt; 3; i++) {
					progId = progIds[i];

					try {
						new ActiveXObject(progId);
						XHR = function(){
							return new ActiveXObject(progId);
						};
						break;
					}
					catch (e) {
					}
				}

				if (!XHR){
					throw new Error(&quot;XHR: XMLHttpRequest not available&quot;);
				}
			}

			return function fetchText(url, callback) {
				var xhr = new XHR();
				xhr.open(&quot;GET&quot;, url, true);
				xhr.onreadystatechange = function () {
					// Do not explicitly handle errors, those should be
					// visible via console output in the browser.
					if (xhr.readyState === 4) {
						callback(xhr.responseText);
					}
				};
				xhr.send(null);
			};
		},

		&quot;rhino&quot; : function () {
			var encoding = &quot;utf-8&quot;;
			var lineSeparator = java.lang.System.getProperty(&quot;line.separator&quot;);

			// Why Java, why is this so awkward?
			return function fetchText(path, callback) {
				var file = new java.io.File(path);
				var input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding));
				var stringBuffer = new java.lang.StringBuffer();
				var line;
				var content = &quot;&quot;;

				try {
					line = input.readLine();

					// Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
					// http://www.unicode.org/faq/utf_bom.html

					// Note that when we use utf-8, the BOM should appear as &quot;EF BB BF&quot;, but it doesn't due to this bug in the JDK:
					// http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
					if (line &amp;&amp; line.length() &amp;&amp; line.charAt(0) === 0xfeff) {
						// Eat the BOM, since we've already found the encoding on this file,
						// and we plan to concatenating this buffer with others; the BOM should
						// only appear at the top of a file.
						line = line.substring(1);
					}

					stringBuffer.append(line);

					while ((line = input.readLine()) !== null) {
						stringBuffer.append(lineSeparator);
						stringBuffer.append(line);
					}
					// Make sure we return a JavaScript string and not a Java string.
					content = String(stringBuffer.toString()); // String
				} finally {
					input.close();
				}

				callback(content);
			};
		},

		&quot;borked&quot; : function () {
			return function fetchText() {
				throw new Error(&quot;Environment unsupported.&quot;);
			};
		}
	};

	var RE_SANITIZE = /^[\n\t\r]+|[\n\t\r]+$/g;
	var RE_BLOCK = /&lt;%(=)?([\S\s]*?)%&gt;/g;
	var RE_TOKENS = /&lt;%(\d+)%&gt;/gm;
	var RE_REPLACE = /([&quot;\n\t\r])/gm;
	var RE_CLEAN = /o \+= &quot;&quot;;| \+ &quot;&quot;/gm;
	var EMPTY = &quot;&quot;;
	var REPLACE = {
		&quot;\&quot;&quot; : &quot;\\\&quot;&quot;,
		&quot;\n&quot; : &quot;\\n&quot;,
		&quot;\t&quot; : &quot;\\t&quot;,
		&quot;\r&quot; : &quot;\\r&quot;
	};

	/*
	 * Compiles template
	 *
	 * @param body Template body
	 * @returns {String}
	 */
	function compile(body) {
		var blocks = [];
		var length = 0;

		function blocksTokens(original, prefix, block) {
			blocks[length] = prefix
				? &quot;\&quot; +&quot; + block + &quot;+ \&quot;&quot;
				: &quot;\&quot;;&quot; + block + &quot;o += \&quot;&quot;;
			return &quot;&lt;%&quot; + String(length++) + &quot;%&gt;&quot;;
		}

		function tokensBlocks(original, token) {
			return blocks[token];
		}

		function replace(original, token) {
			return REPLACE[token] || token;
		}

		return (&quot;function template(data) { var o = \&quot;&quot;
		// Sanitize body before we start templating
		+ body.replace(RE_SANITIZE, &quot;&quot;)

		// Replace script blocks with tokens
		.replace(RE_BLOCK, blocksTokens)

		// Replace unwanted tokens
		.replace(RE_REPLACE, replace)

		// Replace tokens with script blocks
		.replace(RE_TOKENS, tokensBlocks)

		+ &quot;\&quot;; return o; }&quot;)

		// Clean
		.replace(RE_CLEAN, EMPTY);
	}

	var buildMap = {};
	var fetchText = FACTORIES[ typeof process !== &quot;undefined&quot; &amp;&amp; process.versions &amp;&amp; !!process.versions.node
		? &quot;node&quot;
		: (typeof window !== &quot;undefined&quot; &amp;&amp; window.navigator &amp;&amp; window.document) || typeof importScripts !== &quot;undefined&quot;
			? &quot;browser&quot;
			: typeof Packages !== &quot;undefined&quot;
				? &quot;rhino&quot;
				: &quot;borked&quot; ]();

	return {
		load: function (name, parentRequire, load, config) {
			var path = parentRequire.toUrl(name);

			fetchText(path, function (text) {
				try {
					text = &quot;define(function() { return &quot; + compile(text, name, path, config.template) + &quot;; })&quot;;
				}
				catch (err) {
					err.message = &quot;In &quot; + path + &quot;, &quot; + err.message;
					throw(err);
				}

				if (config.isBuild) {
					buildMap[name] = text;
				}

				// IE with conditional comments on cannot handle the
				// sourceURL trick, so skip it if enabled
				/*@if (@_jscript) @else @*/
				else {
					text += &quot;\n//@ sourceURL='&quot; + path +&quot;'&quot;;
				}
				/*@end@*/

				load.fromText(name, text);

				// Give result to load. Need to wait until the module
				// is fully parse, which will happen after this
				// execution.
				parentRequire([name], function (value) {
					load(value);
				});
			});
		},

		write: function (pluginName, name, write) {
			if (buildMap.hasOwnProperty(name)) {
				write.asModule(pluginName + &quot;!&quot; + name, buildMap[name]);
			}
		}
	};
});
</pre>
</body>
</html>
