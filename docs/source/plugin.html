<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*
 * TroopJS browser/loom/plugin
 * @license MIT http://troopjs.mit-license.org/ Â© Mikael Karon mailto:mikael@karon.se
 */
define([
	&quot;jquery&quot;,
	&quot;when&quot;,
	&quot;./config&quot;,
	&quot;./weave&quot;,
	&quot;./unweave&quot;,
	&quot;./woven&quot;,
	&quot;troopjs-utils/getargs&quot;,
	&quot;poly/array&quot;
], function WeaveModule($, when, config, weave, unweave, woven, getargs) {
	&quot;use strict&quot;;

	var UNDEFINED;
	var $FN = $.fn;
	var $EXPR = $.expr;
	var $CREATEPSEUDO = $EXPR.createPseudo;
	var WEAVE = &quot;weave&quot;;
	var UNWEAVE = &quot;unweave&quot;;
	var WOVEN = &quot;woven&quot;;
	var ATTR_WEAVE = config[WEAVE];
	var ATTR_WOVEN = config[WOVEN];
	var RE_SEPARATOR = /[\s,]+/;

	/*
	 * Tests if element has a data-weave attribute
	 * @param element to test
	 * @returns {boolean}
	 * @private
	 */
	function hasDataWeaveAttr(element) {
		return $(element).attr(ATTR_WEAVE) !== UNDEFINED;
	}

	/*
	 * Tests if element has a data-woven attribute
	 * @param element to test
	 * @returns {boolean}
	 * @private
	 */
	function hasDataWovenAttr(element) {
		return $(element).attr(ATTR_WOVEN) !== UNDEFINED;
	}

	/*
	 * :weave expression
	 */
	$EXPR[&quot;:&quot;][WEAVE] = $CREATEPSEUDO
		// If we have jQuery &gt;= 1.8 we want to use .createPseudo
		? $CREATEPSEUDO(function (widgets) {
			// If we don't have widgets to test, quick return optimized expression
			if (widgets === UNDEFINED) {
				return hasDataWeaveAttr;
			}

			// Convert widgets to RegExp
			widgets = new RegExp(getargs.call(widgets).map(function (widget) {
				return &quot;^&quot; + widget;
			}).join(&quot;|&quot;), &quot;m&quot;);

			// Return expression
			return function (element) {
				// Get weave attribute
				var weave = $(element).attr(ATTR_WEAVE);

				// Check that weave is not UNDEFINED, and that widgets test against a processed weave
				return weave !== UNDEFINED &amp;&amp; widgets.test(weave.replace(RE_SEPARATOR, &quot;\n&quot;));
			};
		})
		// Otherwise fall back to legacy
		: function (element, index, match) {
			var weave = $(element).attr(ATTR_WEAVE);

			return weave === UNDEFINED
				? false
				: match === UNDEFINED
					? true
					: new RegExp(getargs.call(match[3]).map(function (widget) {
							return &quot;^&quot; + widget;
						}).join(&quot;|&quot;), &quot;m&quot;).test(weave.replace(RE_SEPARATOR, &quot;\n&quot;));
			};

	/*
	 * :woven expression
	 */
	$EXPR[&quot;:&quot;][WOVEN] = $CREATEPSEUDO
		// If we have jQuery &gt;= 1.8 we want to use .createPseudo
		? $CREATEPSEUDO(function (widgets) {
			// If we don't have widgets to test, quick return optimized expression
			if (widgets === UNDEFINED) {
				return hasDataWovenAttr;
			}

			// Convert widgets to RegExp
			widgets = new RegExp(getargs.call(widgets).map(function (widget) {
				return &quot;^&quot; + widget;
			}).join(&quot;|&quot;), &quot;m&quot;);

			// Return expression
			return function (element) {
				var attr_woven = $(element).attr(ATTR_WOVEN);

				// Check that attr_woven is not UNDEFINED, and that widgets test against a processed attr_woven
				return attr_woven !== UNDEFINED &amp;&amp; widgets.test(attr_woven.replace(RE_SEPARATOR, &quot;\n&quot;));
			};
		})
		// Otherwise fall back to legacy
		: function (element, index, match) {
			var attr_woven = $(element).attr(ATTR_WOVEN);

			return attr_woven === UNDEFINED
				? false
				: match === UNDEFINED
					? true
					: new RegExp(getargs.call(match[3]).map(function (widget) {
						return &quot;^&quot; + widget;
					}).join(&quot;|&quot;), &quot;m&quot;).test(attr_woven.replace(RE_SEPARATOR, &quot;\n&quot;));
		};

<span id='$'>	/**
</span>	 * @class $
	 */

<span id='$-method-weave'>	/**
</span>	 * Weaves elements
	 * @member $
	 * @method weave
	 * @returns {Promise} of weaving
	 */
	$FN[WEAVE] = weave;

<span id='$-method-unweave'>	/**
</span>	 * Unweaves elements
	 * @member $
	 * @method unweave
	 * @returns {Promise} of unweaving
	 */
	$FN[UNWEAVE] = unweave;

<span id='$-method-woven'>	/**
</span>	 * Gets woven widgets
	 * @method woven
	 * @returns {Promise} of woven widgets
	 */
	$FN[WOVEN] = woven;
});
</pre>
</body>
</html>
